# Import packages.
import pandas as pd 
import streamlit as st 

# Read in supporting functions from the same directory.
import ugraphql
import data_models
import catalog

# Read in programs data to be used in this package.
programs = catalog.fetch_catalog()
programs_df = pd.DataFrame(programs)

def generateSkillsReport(data):

	"""
	Renders the skills report that defines the skill coverage for a given learning plan.
	
		Args:
			data: the data that was generated by OpenAI.

		Returns:
			prints a DataFrame using st.dataframe into the streamlit application.
	"""

	# Get the correct attribute from the data.
	data = data.subjects

	# Create a DataFrame from the list of subjects
	df = pd.DataFrame(data={
		"subject": [subject.subject for subject in data],
		"coverage":  [subject.coverage for subject in data]
		})

	# Initialize empty columns for Weak, Medium, and Strong
	df["Weak"] = df["coverage"].apply(lambda x: "âœ”" if x == "Weak" else "")
	df["Medium"] = df["coverage"].apply(lambda x: "âœ”" if x == "Medium" else "")
	df["Strong"] = df["coverage"].apply(lambda x: "âœ”" if x == "Strong" else "")

	# Drop the 'coverage' column and reorder the columns
	df = df.drop(columns="coverage")[["subject", "Weak", "Medium", "Strong"]]

	# Display the DataFrame as a table
	st.dataframe(df,use_container_width=True)

def fetch_program_metadata(step, programs=programs):

	"""
	While OpenAI is making the decisions for the steps in the Learning Plan, all it is selecting
	are the program keys and their order. This function handles fetching all of the relevant catalog
	data from the unified catalog data we have saved. Doing it this way significantly reduces the surface area
	where hallucinations can occur.

		Args:
			step: A Udacity program. Typically this will be a step in a Learning Plan, but it can also be
			used on an individual program for some standalone catalog management use cases.
			programs: the data from the unified catalog.

		Returns:
			A dictionary `step_dict` that has all of the required metadata on the program in that step.
	"""

	# Fill out the required metadata for each catalog step. Anywhere you see the code starting with next((item['... is somewhere
	# where we are fetching metadata from the catalog. The rest comes directly from the step.
	step_dict = {
		"step_type": step.step_type.value,
		"program_key": step.program_key,
		"title": next((item['title'] for item in programs if item['program_key']==step.program_key)),
		"duration": next((item['duration'] for item in programs if item['program_key']==step.program_key)),
		"catalog_url": next((item['catalog_url'] for item in programs if item['program_key']==step.program_key)),
		"short_description": next((item['summary'] for item in programs if item['program_key']==step.program_key)),
		"long_description": next((item['summary'] for item in programs if item['program_key']==step.program_key)),
		"skills": next((item['skill_names'] for item in programs if item['program_key']==step.program_key)),
		"recommendation_reason": step.recommendation_reason if hasattr(step, 'recommendation_reason') else '',
		"difficulty": next((item['difficulty'] for item in programs if item['program_key']==step.program_key)),
		"structure_data": None
		}

	return step_dict

def formatLearningPlan(response):

	"""
	A function to wrap around the `step_to_dict` that can create the full data structure
	required for rendering a learning plan.

		Args:
			response: the data from OpenAI.

		Returns:
			The data structure of a learning plan, with all of the neste data sorted out by
			`step_to_dict` function.
	"""

	# Convert the entire learning plan to a dictionary
	response_dict = {
		"key": response.key,
		"version": response.version,
		"title": response.title,
		"short_title": response.short_title,
		"slug": response.slug,
		"video_url": response.video_url,
		"image_url": response.image_url,
		"short_description": response.short_description,
		"long_description": response.long_description,
		"solution_coverage": response.solutionCoverage,
		"solution_gap": response.solutionGap,
		"prerequisites": response.prerequisites,
		"extracurricular": response.extracurricular,
		"steps": [fetch_program_metadata(step) for step in response.steps],
		}

	return response_dict

def generateLearningPlan(plan):
	"""
	Main function that wraps all of the utilities up to display
	a Learning Plan to a user

		Args:
			plan: the cleaned up data from the Learning Plan.

		Returns:
			Renders on a users screen all of the information about the 
			Learning Plan.
	"""
	st.markdown(f'### {plan.get("title", "Learning Plan")}')
	
	# Plan Summary
	display_plan_summary(plan)
	
	# Render each step
	for idx, step in enumerate(plan.get('steps', [])):
		display_step(idx, step)

	# Display advanced extracurriculars
	display_extracurriculars(plan.get('extracurricular', 'N/A'))

def display_plan_summary(plan):
	"""
	Displays the plan-level metadata using primarily streamlit markdown.

	Args:
		plan: the cleaned up data from the Learning Plan.

	Returns:
		Renders the plan-level information.
	"""
	description = (plan.get('short_description', '') + ' ' + plan.get('long_description', '')).strip()
	coverage = plan.get('solution_coverage', 'N/A')
	gap = plan.get('solution_gap', 'N/A')
	
	with st.expander('Summary'):
		st.markdown(f'* **Description**: {description}')
		st.markdown(f'* **Solution Coverage**: {coverage}')
		st.markdown(f'* **Solution Gaps**: {gap}')

def fetch_lesson_data(program_key):

	"""
	For a given program, fetch all of the lesson data from GraphQL so it can be displayed as
	part of the data about the program.

		Args:
			program_key: the Udacity program key of the content offering.

		Returns:
			A dataset of the lesson data associated with that program.
	"""

	# Sometimes, issues occur here. There is a risk of hallucination that OpenAI makes up the program key.
	# If the program key can't be found in classroom content's GraphQL endpoint, then return None -- this will
	# be a trigger downstream to warn us of potential hallucination.
	try:
		# We need to use slightly different queries to get the right data for Courses (cd), Nanodegrees (nd), and Free Courses (ud).
		if 'cd' in program_key:
			response = ugraphql.fetchData(query=ugraphql.queryCourseStructure(program_key), url=ugraphql.classroomContentUrl)
			parts = response['data']['part']
			if isinstance(parts, list):
				response = [p for p in parts if p['is_default']==True][0]
			else:
				response = [parts]
			structure = [response[0]]
		if 'nd' in program_key:
			response = ugraphql.fetchData(query=ugraphql.queryNanodegreeStructure(program_key), url=ugraphql.classroomContentUrl)
			nanodegrees = response['data']['nanodegrees']
			if isinstance(nanodegrees, list):
				response = [nanodegree for nanodegree in nanodegrees if nanodegree['is_default']==True]
			else:
				response = [nanodegrees if nanodegrees['is_default']==True else []][0]
			structure = [part for part in response[0]['parts']]
		if 'ud' in program_key:
			response = ugraphql.fetchData(query=ugraphql.queryFreeCourseStructure(program_key), url=ugraphql.classroomContentUrl)
			courses = response['data']['courses']
			if isinstance(courses, list):
				response = [c for c in courses if c['is_default']==True][0]
			else:
				response = [courses]
			structure = [response]

	# Couldn't find the program key? Return None.
	except:
		return None

	# If some sort of structure was found, return the structured.
	return structure

def render_lessons(lesson_data):
	"""
	Render the lesson data as part of the results shown to the user in their Learning Plan.

		Args:
			lesson_data: the lesson data feteched from GraphQL.

		Returns:
			Lesson metadata to be included in the HTML rendering of the learning plan step.
	"""

	# If lesson_data is None, then there is a chance there was hallucination. Only return an error.
	if lesson_data == None:
		return 'ðŸ¤– <i>Error fetching lesson-level data.</i>'

	# Otherwise, unpack the lesson data into HTML.
	lesson_html = ""
	for part in lesson_data:
		lesson_html += f"{part['title']}{optional(part)}{extracurricular(part)}{career(part)}"
		lesson_html += "<ol>"

		try:
			for lesson in part['modules'][0]['lessons']:
				lesson_html += f"<li>Lesson: {lesson['title']}</li>"
		except:
			for lesson in part['lessons']:
				lesson_html += f"<li>Lesson: {lesson['title']}</li>"	
		lesson_html += "</ol>"

	# Return HTML.
	return lesson_html

def format_badge(text):
	"""
	A utility function to format badge components on the frontend.
	"""
	return f'<span style="background-color: #142580; color: #fff; border-radius: 16px; padding: 4px 12px;">{text}</span>'

def optional(part):
	"""
	A utility function to format "Optional" badge components on the frontend.
	"""
	return ' <span class="badge badge-primary">Optional</span>' if part.get('is_optional') else ''

def extracurricular(part):
	"""
	A utility function to format "Extracurricular" badge components on the frontend.
	"""
	return ' <span class="badge badge-primary">Extracurricular</span>' if part.get('is_extracurricular') else ''

def career(part):
	"""
	A utility function to format "Career" badge components on the frontend.
	"""
	return ' <span class="badge badge-primary">Career</span>' if part.get('is_career') else ''

def render_skills(skills):
	"""
	A utility function to format "Skill" badge components on the frontend (typically there is a list of these).
	"""
	return ' '.join([f'<span class="badge badge-primary">{skill}</span>' for skill in skills])

def display_extracurriculars(extracurriculars):
	"""
	Display extracurricular courses a user could choose to take after they have completed the Learning Plan.

		Args:
			extracurriculars: The courses recommended by OpenAI.

		Returns:
			Renders HTMl for the extra curricular courses.
	"""
	with st.expander('Advanced Extracurriculars'):
		catalog.showCourses(programs_df[programs_df['program_key'].isin(extracurriculars)], num_columns=1)

def display_step(idx, step):
	"""
	Renders each step in the Learning Plan for a user to see.

		Args:
			idx: the index of the step's location in the Learning Plan.
			step: the data about that step.

		Returns:
			HTML rendering of the step passed through streamlit markdown.
	"""
	with st.expander(f"Step {idx + 1}: {step.get('title')} ({step.get('step_type')})"):
		st.markdown(f"""
			<div style="border: 1px solid #ddd; padding: 15px; background-color: rgba(255,255,255,0);">
				<h3>{step['title']}</h3>
				<div style="display: flex; gap: 10px;">
					{format_badge(step.get('duration', ''))}
					{format_badge(step.get('step_type', ''))}
					{format_badge(step.get('difficulty', ''))}
				</div>
				<p>{step['short_description']}</p>
				<a href="{step['catalog_url']}" target="_blank" style="color: #007bff;">Learn More</a>
				<div><strong>Skills</strong></div>
				{render_skills(step.get('skills', []))}
				<div><strong>Syllabus</strong></div>
				{render_lessons(fetch_lesson_data(step.get('program_key')))}
				<div style="margin-top: 15px; color: #888;">
					Recommendation reason: {step['recommendation_reason']}
				</div>
			</div>
		""", unsafe_allow_html=True)